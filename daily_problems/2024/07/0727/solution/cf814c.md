**提示 1：** 要让一个区间能经过 $m$ 次赋值为 $c$ 的操作变成全由 $c$ 组成，则区间中非 $c$ 的字符个数不超过 $m$ .

**提示 2：** 对于同一组 $(m,c)$ ，可以如何快速计算答案？

**提示 3：** 但题目中需要多次查询，这怎么办？（注意 $m,c$ 范围均不大）

首先，我们先考虑解决一组查询。

即我们要看修改 $m$ 个字符后，最长的仅仅由 $c$ 构成的子串有多长。

而最后选取的子串中，非 $c$ 字符的数量不能超过 $m$ 个，这也是选取的子串唯一需要满足的条件。

综上，只需求 **非 $c$ 字符个数不超过 $m$ 个的字符的子串最大长度** 。

子串问题可以想到使用双指针解决，维护双指针内非 $c$ 字符的个数即可，因此单组查询可以 $\mathcal{O}(n)$ 解决。

（之所以可以使用双指针，是因为右端点关于左端点单调递增）

接下来处理多次查询。

如果每次查询都使用 $\mathcal{O}(n)$ 解答，则总复杂度达到 $\mathcal{O}(nq)$ ，不是合理的复杂度，那怎么办呢？

我们发现，查询的 $c$ 只有 $|\Sigma|=26$ 种取值，查询的 $m$ 不超过 $n$ ，因此 **不同的查询总数为 $n|\Sigma|$** ，于是我们实际需要用 $\mathcal{O}(n)$ 处理的查询也只有这么多，剩下的都是求过的查询，可以 $\mathcal{O}(1)$ 查答案。

因此我们预处理这 $n|\Sigma|$ 个不同查询的答案，后续直接查表即可。时间复杂度为 $\mathcal{O}(n^2|\Sigma|+q)$ .

