**提示 1：** 我们要数一个图形的数量，关键在于找出图形的特点与关键点。

**提示 2：** 找到关键点后，枚举关键点，对剩余的部分进行计数。

我们要数图中所给的图形的数量。

由于其整体是比较对称的，因此相对而言，关键点的选取可以很多样。

而根据数据范围推测，整体的复杂度允许在 $n^2$ 或 $nm$ 量级，因此可以选择枚举两个点。

如果我们选择枚举 $(a,c)$ ，我们就需要统计的是中间的 $(b,d)$ 对情况，$b,d$ 需要满足的条件一致，即这一步的要求是：

**有多少个 $x$ 使得 $a$ 到 $x$ 有边，$x$ 到 $c$ 有边，再从中选取两个点作为 $b,d$** 。

（这里，后继和前驱的表述不规范，只是表示一步可达的点和一步往前的点。）

如果我们直接对比 $a$ 的后继和 $c$ 的前驱，也许可以使用 bitset 加快对比，但这是没有必要的。我们只需要考虑所有 $a$ 的后继，接下来 $\mathcal{O}(1)$ 检查其是否有到 $c$ 的边即可。

这样的复杂度如何呢？我们将枚举 $a$ 加上 $a$ 的后继理解为一步，这一步的复杂度是 $\mathcal{O}(m)$ 的，即总边数；再把枚举 $c$ 作为第二步，这一步的复杂度是 $\mathcal{O}(n)$ 的。于是，总复杂度是 $\mathcal{O}(nm)$ 的。

直接写成枚举 $(a,c)$ 的形式会用时较长。

这里可以在枚举 $a$ 后继 $x$ 后，直接进一步枚举 $x$ 的后继 $y$ ，这样总复杂度仍然不超过 $x$ 引出的边数乘以 $x$ 的后继数量，复杂度仍然满足要求。

这种写法可以直接统计 $a$ 到达点 $y$ 的方案数量，再用 $\frac{cnt(cnt-1)}{2}$ 计算即可。这样第二步的 $\mathcal{O}(n)$ 就很可能是跑不满的了。

选择枚举 $(b,d)$ 也是可以做的。枚举 $b$ 的前驱看其是否是 $d$ 的前驱，枚举 $b$ 的后继看其是否是 $d$ 的后继，最后再去掉既然是两者前驱又是两者后继的点即可。这种方法没有很明显的优化空间。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m = MII()

    def f(x, y):
        return x * n + y

    path = [[] for _ in range(n)]
    for _ in range(m):
        u, v = GMI()
        path[u].append(v)

    cnt = [0] * n

    ans = 0
    for i in range(n):
        for j in path[i]:
            for k in path[j]:
                cnt[k] += 1
        for j in range(n):
            if j != i:
                ans += cnt[j] * (cnt[j] - 1) // 2
            cnt[j] = 0

    print(ans)
```

C++ 做法如下——

```cpp []
TBD
```