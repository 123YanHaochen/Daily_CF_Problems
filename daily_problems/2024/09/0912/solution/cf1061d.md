**提示 1：** 


时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, x, y = MII()

    ls = []
    rs = []

    ans = 0
    mod = 10 ** 9 + 7

    for _ in range(n):
        l, r = MII()
        ls.append(l)
        rs.append(r + 1)
        ans += (r + 1 - l) * y % mod
        if ans >= mod: ans -= mod

    st_range = sorted(range(n), key=lambda x: ls[x])

    hpq_using = []
    hpq_used = []

    for i in st_range:
        while hpq_using and hpq_using[0] <= ls[i]:
            heappush(hpq_used, -heappop(hpq_using))
        
        if hpq_used and (x - y) // y >= ls[i] + hpq_used[0]:
            ans += (ls[i] + heappop(hpq_used)) * y
        else:
            ans += x - y
        
        if ans >= mod: ans -= mod
        heappush(hpq_using, rs[i])

    print(ans)
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, x, y;
    cin >> n >> x >> y;

    vector<int> ls(n), rs(n);
    int ans = 0, mod = 1e9 + 7;

    for (int i = 0; i < n; i ++) {
        cin >> ls[i] >> rs[i];
        rs[i] ++;
        ans += 1ll * (rs[i] - ls[i]) * y % mod;
        if (ans >= mod) ans -= mod;
    }

    vector<int> st_range(n);
    iota(st_range.begin(), st_range.end(), 0);
    sort(st_range.begin(), st_range.end(), [&](int i, int j) {return ls[i] < ls[j];});

    priority_queue<int, vector<int>, greater<int>> pq_using;
    priority_queue<int> pq_used;

    for (auto &i: st_range) {
        while (!pq_using.empty() && pq_using.top() <= ls[i]) {
            int v = pq_using.top();
            pq_using.pop();
            pq_used.push(v);
        }
        if (!pq_used.empty() && (x - y) / y >= ls[i] - pq_used.top()) {
            int v = pq_used.top();
            pq_used.pop();
            ans += (ls[i] - v) * y;
        }
        else ans += x - y;

        if (ans >= mod) ans -= mod;
        pq_using.push(rs[i]);
    }

    cout << ans;

    return 0;
}
```
