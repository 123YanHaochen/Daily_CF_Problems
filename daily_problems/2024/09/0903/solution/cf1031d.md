**提示 1：** 最后构造的字符串长度是相同的，而要考虑其字典序。

**提示 2：** 我们的操作只可能将元素变为 `'a'` ，同时操作的一定是前缀。

**提示 3：** 先最大化前缀 `'a'` 的个数。接下来怎么走？

首先，我们的操作只会使得字符变成 `'a'` ，因为变成其他的一定不如变成 `'a'` 。

其次，我们操作的位置一定在最后字符串的前缀中。不然，如果最后的字符串中，后面有个字符被操作成了 `'a'` ，但前缀中有非 `'a'` 元素，我们可以把操作的字符变成前面的位置，字典序一定更小。

于是最后一定使得前缀有一堆 `'a'` ，后面的部分相当于无法修改地在矩阵中走。

因此，先考虑最大化前缀的 `'a'` 。我们考虑走到某个位置 $(i,j)$ 且前面的字符都是 `'a'` 的最小修改次数。这件事显然可以通过动态规划解决，因为前一步只可能是 $(i-1,j),(i,j-1)$ ，因此我们可以得到走到所有位置全是 `'a'` 的最小修改次数。

而其中我们应该选择修改次数小于等于 $k$ 的距离 $(0,0)$ 最远的点作为起点，这样才能使得前缀的 `'a'` 尽可能多。假设点形成了集合 $st$ ，接下来我们从 $st$ 出发继续往右下角走。

下一步往哪里走呢？考虑所有 $st$ 的点往右 / 往下一格形成的字符集，其中最小值就是下一步应该取的字符。而对应的一系列格点就是下一次行动的点集，将 $st$ 替换为这一系列点即可。相当于一步步使用贪心。

注意，当 $k=0$ 且 $grid[0][0]$ 非 `'a'` 时，前缀可能没有 `'a'` ，可能需要处理。

时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, k = MII()
    ans = list(range(1, n + 1))

    def op(l, r):
        global k
        if k == 0 or l + 1 == r: return
        m = (l + r) // 2
        k -= 1
        ans[m-1], ans[m] = ans[m], ans[m-1]
        op(l, m)
        op(m, r)

    if k % 2 == 0:
        exit(print(-1))
    k //= 2
    op(0, n)
    print(' '.join(map(str, ans)) if k == 0 else -1)
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, k;
    cin >> n >> k;

    if ((k & 1) == 0)
        return cout << -1, 0;
    
    vector<int> ans(n);
    iota(ans.begin(), ans.end(), 1);

    auto op = [&] (auto &self, int l, int r) {
        if (k == 0 || l + 1 == r) return;
        int m = (l + r) / 2;
        k --;
        swap(ans[m-1], ans[m]);
        self(self, l, m);
        self(self, m, r);
    };

    k /= 2;
    op(op, 0, n);

    if (k) cout << -1;
    else for (auto &x: ans) cout << x << ' ';

    return 0;
}
```

