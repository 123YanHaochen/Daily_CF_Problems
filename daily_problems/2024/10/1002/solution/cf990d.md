**提示 1：** 如果一个图不连通，则它的补图连通。尝试证明这件事。

**提示 2：** 于是 $a,b$ 至少有一个是 $1$ ，尝试利用上面的结论构造。

首先如果一个图不连通，则它的补图连通。怎么证明呢？

对于原图中不连通的两个点，在补图中两者直接相连，因此连通；而对于原图中连通的两个点，**找另一个连通块中的一点**，则这两个点和另一连通块中的任意点都直接相连，因此连通。

于是，证明了上述结论。

综上， $a,b$ 至少有一个是 $1$ 。

如果 $a\gt 1,b=1$ ，则我们只需要构造一个有 $a$ 个连通块的原图，则再使用上述结论，补图一定连通。这很容易构造。

$a=1,b\gt 1$ 的情况跟上面 $a\gt 1, b=1$ 的情况可以对应，我们只需构造有 $b$ 个连通块的补图即可。

对于 $a=1,b=1$ ，我们构造原图时，为了补图尽可能连通，应该让原图的边越少越好，于是考虑构造一条链。于是发现，除非 $n=2/3$ ，这样的构造都是合法的。

接下来确认 $n=2/3$ ，发现确实无法构造，于是得到答案。

时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m, a = MII()
    nums1 = LII()
    nums2 = LII()

    nums1.sort()
    nums2.sort()

    l, r = 0, min(n, m)
    while l <= r:
        mid = (l + r) // 2
        cur = 0
        for i in range(mid):
            cur += fmax(nums2[i] - nums1[n - mid + i], 0)
            if cur > a:
                r = mid - 1
                break
        else:
            l = mid + 1

    print(r, fmax(0, sum(nums2[:r]) - a))
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m, a;
    cin >> n >> m >> a;

    vector<int> nums1(n), nums2(m);

    for (auto &v: nums1) cin >> v;
    for (auto &v: nums2) cin >> v;

    sort(nums1.begin(), nums1.end());
    sort(nums2.begin(), nums2.end());

    int l = 0, r = min(n, m);

    while (l <= r) {
        int mid = (l + r) / 2, cur = 0;
        bool flg = true;
        for (int i = 0; i < mid; i ++) {
            cur += max(nums2[i] - nums1[n - mid + i], 0);
            if (cur > a) {
                flg = false;
                break;
            }
        }
        if (flg) l = mid + 1;
        else r = mid - 1;
    }

    int ans = -a;
    for (int i = 0; i < r; i ++) 
        ans += nums2[i];

    cout << r << ' ' << max(0, ans);

    return 0;
}
```
